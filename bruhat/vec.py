#!/usr/bin/env python3

"""
Category of finite dimensional vector spaces as a compact closed category.
We avoid using associators by treating tensor as a multi-arity operation.
(Even though python treats it as a binary operation.)
Based on rel.py 

See:
Physics, Topology, Logic and Computation: A Rosetta Stone
John C. Baez, Mike Stay
https://arxiv.org/abs/0903.0340

Also:
2-Hilbert spaces:
https://arxiv.org/pdf/q-alg/9609018.pdf
"""

#from functools import lru_cache # fail
from random import randint, seed

import numpy

from bruhat import element
from bruhat import elim
from bruhat.element import Keyed, Type, Element


class Space(Keyed, Type):
    "Vector space with a basis, over a ring."
    "Vector space _generated by a set."

    def __init__(self, gen, ring):
        if type(gen) is int:
            gen = [(i,) for i in range(gen)]
        else:
            gen = [(x if type(x) is tuple else (x,)) for x in gen]
        try:
            gen.sort() # <------- canonical <-----
        except TypeError:
            # unorderable types
            #gen.sort(key = lambda a:id(a)) # too difficult...
            raise 
        self.gen = tuple(gen)
        self.set_gen = set(gen)
        self.dim = len(gen)
        self.ring = ring
        #self.vec_hom = Hom(self.unit(self.ring), self)
        Type.__init__(self)
        #Keyed.__init__(self, (self.gen, self.ring))

    def __getitem__(self, i):
        return self.gen[i]

    def __len__(self):
        return len(self.gen)

    def __contains__(self, x):
        return x in self.set_gen

    def __str__(self):
        return "Space(%s, %s)"%(str(list(self.gen)), self.ring)
    __repr__ = __str__

    def __eq__(A, B):
        assert A.ring == B.ring
        return A.gen == B.gen

    def __ne__(A, B):
        assert A.ring == B.ring
        return A.gen != B.gen

    def __hash__(self):
        return hash(self.gen)

    the_star = ("*",)

    @classmethod
    def unit(cls, ring):
        "Tensor unit object"
        return cls([cls.the_star], ring)
    
    def get_basis(self, i=None):
        if i is None:
            return [self.get_basis(i) for i in range(self.dim)]
        assert 0<=i<self.dim
        x = self.gen[i]
        ring = self.ring
#        v = Map([((x, self.the_star), self.ring.one)], Hom(self.unit(self.ring), self))
        vec_hom = Hom(self.unit(self.ring), self)
        v = Map([((x, self.the_star), self.ring.one)], vec_hom)
        return v

    def zero_vector(self):
        vec_hom = Hom(self.unit(self.ring), self)
        v = vec_hom.zero_vector()
        return v

    def __add__(A, B):
        assert A.ring == B.ring
        assert not A.set_gen.intersection(B.set_gen)
        gen = A.gen + B.gen
        return Space(gen, A.ring)

    def tensor(A, B):
        assert A.ring == B.ring
        gen = [x+y for x in A.gen for y in B.gen] # tuple addition
        return Space(gen, A.ring)
    __matmul__ = tensor
        
    def __mul__(A, B):
        assert A.ring == B.ring
        if A==B:
            return A
        else:
            assert 0

    @classmethod
    def zero(cls, ring):
        "zero object"
        return cls([], ring)
    
    @property
    def dual(self):
        # XX um...
        return self

    def endo_hom(self):
        return Hom(self, self)

    @property
    def ident(self): # XX cache me
        "ident: A --> A"
        ring = self.ring
        one, zero = ring.one, ring.zero
        items = [((x, x), one) for x in self.gen]
        ident = Map(items, Hom(self, self))
        return ident

    @property
    def left_unitor(self): # XX cache me
        "IxA --> A"
        src = Space.unit(self.ring) @ self
        tgt = self
        one = self.ring.one
        items = [((x, Space.the_star+x), one) for x in self.gen] # tuple addition
        return Map(items, Hom(src, tgt))

    @property
    def right_unitor(self): # XX cache me
        "AxI --> A"
        src = self @ Space.unit(self.ring)
        tgt = self
        one = self.ring.one
        items = [((x, x+Space.the_star), one) for x in self.gen] # tuple addition
        return Map(items, Hom(src, tgt))

    @property
    def cap(self): # XX cache me
        "the unit, eta: I --> A*xA"
        src = Space.unit(self.ring)
        the_star = Space.the_star
        tgt = self.dual @ self
        one = self.ring.one
        items = [((x+x, the_star), one) for x in self.gen] # tuple addition
        return Map(items, Hom(src, tgt))

    @property
    def cup(self): # XX cache me
        "the co-unit, epsilon: AxA* --> I"
        tgt = Space.unit(self.ring)
        the_star = Space.the_star
        src = self @ self.dual
        one = self.ring.one
        items = [((the_star, x+x), one) for x in self.gen] # tuple addition
        return Map(items, Hom(src, tgt))

    def inject_to(self, other):
        one = self.ring.one
        items = []
        for i in self.gen:
            assert i in other.set_gen, "%s not in %s"%(i, self.set_gen)
            items.append(((i, i), one))
        hom = Hom(self, other)
        return Map(items, hom)


class Hom(Keyed, Type):
    def __init__(self, src, tgt):
        assert isinstance(src, Space)
        assert isinstance(tgt, Space)
        assert src.ring == tgt.ring
        Keyed.__init__(self, (src, tgt))
        Type.__init__(self)
        self.ring = src.ring
        self.src = src
        self.tgt = tgt
        self.shape = (tgt.dim, src.dim)

    def __str__(self):
        return "Hom(%s, %s)"%(self.src, self.tgt)

#    @property
#    def zero(self):
#        return Map([], self) # the zero map

    @property
    def one(self):
        assert self.src == self.tgt
        return self.src.inject_to(self.tgt)

    def zero_vector(self):
        v = Map([], self)
        return v

    def __getitem__(self, i):
        return [self.src, self.tgt][i]

    def tensor(a, b):
        # not sure if this makes sense mathematically..
        src = a.src @ b.src
        tgt = a.tgt @ b.tgt
        return Hom(src, tgt)
    __matmul__ = tensor

    def __mul__(a, b):
        assert b.tgt == a.src, "%s != %s" % (b.tgt, a.src)
        return Hom(b.src, a.tgt)

    def transpose(a):
        return Hom(a.tgt, a.src)


class Map(Element):

    def __init__(self, _items, hom):
        assert isinstance(hom, Hom)
        Element.__init__(self, hom)
        ring = hom.src.ring
        zero = ring.zero
        assert hom.tgt.ring == ring
        items = []
        keys = []
        for item in _items:
            (i, j), _val = item
            val = ring.promote(_val)
            assert val is not None, (ring, _val)
            i = (i if type(i) is tuple else (i,))
            j = (j if type(j) is tuple else (j,))
            if val != zero: # make canonical. sparse
                items.append(((i, j), val))
                keys.append((i, j))
            assert val.tp == ring
            assert i in hom.tgt, "%s not found in %s" % (i, hom.tgt) # row
            assert j in hom.src, "%s not found in %s" % (j, hom.src) # col
        assert len(keys)==len(items), "duplicate key: %s" % (keys)
        items.sort() # Make canonical. careful with this...
        self.items = tuple(items)
        self.map_items = dict(items)
        self.src = hom.src
        self.tgt = hom.tgt
        self.hom = hom
        self.shape = hom.shape
        self.ring = ring

    def __getitem__(self, k):
        i, j = k
        assert i in self.tgt
        assert j in self.src
        return self.map_items.get(k, self.ring.zero)

    def __repr__(self):
        return "Map(%s)"%(str(list(self.items)))

    def str(self, labels=False, hide_zero=False, element_str=str, sep=' '):
        zero = '.' if hide_zero else self.ring.zero
        map_items = self.map_items
        rows = [[element_str(map_items.get((i, j), zero)) 
            for j in self.src.gen] for i in self.tgt.gen]
        w = 1
        for row in rows:
            for col in row: 
                w = max(w, len(col))
        rows = ['[%s]'%sep.join(s.rjust(w) for s in row) for row in rows]
        lines = [] 
        for i, row in enumerate(rows):
            if i==0:
                row = "["+row
            else:
                row = " "+row
            if i==len(rows)-1:
                row = row+"]"
            else:
                row = row+","
            if labels:
                row += ' ' + str(self.tgt.gen[i])
            lines.append(row)
        s = '\n'.join(lines) or "[]"
        #s += str(self.hom.shape)
        return s
    __str__ = str

    def longstr(self):
        return self.str(labels=True, hide_zero=True)

    def to_array(self):
        zero = self.ring.zero
        map_items = self.map_items
        rows = [[map_items.get((i, j), zero)
            for j in self.src.gen] for i in self.tgt.gen]
        A = numpy.array(rows)
        assert A.shape == self.hom.shape
        return A

    @classmethod
    def from_array(cls, A, hom):
        ring = hom.ring
        zero = ring.zero
        items = []
        A = numpy.array(A)
        assert A.shape == hom.shape, "%s != %s" % (A.shape, hom.shape)
        for idx, i in enumerate(hom.tgt.gen):
          for jdx, j in enumerate(hom.src.gen):
            u = A[idx, jdx]
            if u != zero:
                items.append(((i, j), u))
        return cls(items, hom)

    def __eq__(a, b):
        return a.items == b.items

    def __ne__(a, b):
        return a.items != b.items

    def __hash__(self):
        return hash(self.items)

    def __contains__(self, item):
        return item in self.set_items

    # these operations could also live in the Hom:

    def __add__(a, b):
        assert a.hom == b.hom
        zero = a.ring.zero
        map_items = dict(a.items)
        for ((i, j), u) in b.items:
            val = map_items.get((i, j), zero) + u
            map_items[i, j] = val
        items = list(map_items.items())
        return Map(items, a.hom)

    def __sub__(a, b):
        assert a.hom == b.hom
        zero = a.ring.zero
        map_items = dict(a.items)
        for ((i, j), u) in b.items:
            val = map_items.get((i, j), zero) - u
            map_items[i, j] = val
        items = list(map_items.items())
        return Map(items, a.hom)

    def __neg__(a):
        items = [((i, j), -u) for ((i, j), u) in a.items]
        return Map(items, a.hom)

    def tensor(a, b):
        hom = a.hom@b.hom
        items = [
            ((x+y, u+v), val*wal)
            for ((x, u), val) in a.items 
            for ((y, v), wal) in b.items]
        return Map(items, hom)
    __matmul__ = tensor # yeah baby

#    def __rmul__(a, r):
#        return NotImplemented

    def __mul__(a, b):
        hom = a.hom*b.hom
        zero = a.ring.zero
        map_items = dict()
        for ((i, j), u) in a.items:
          for ((j1, k), v) in b.items:
            if j != j1:
                continue
            val = map_items.get((i, k), zero) + u*v
            map_items[i, k] = val
        items = list(map_items.items())
        return Map(items, hom)

    def __rmul__(a, r):
        #assert isinstance(r, Element)
        #assert r.tp == self.ring
        r = a.ring.promote(r)
        items = [((i, j), u*r) for ((i, j), u) in a.items]
        return Map(items, a.hom)

    def __floordiv__(a, r): # a // r
        r = a.ring.promote(r)
        items = [((i, j), u//r) for ((i, j), u) in a.items]
        return Map(items, a.hom)

    def __truediv__(a, r): # a / r
        r = a.ring.promote(r)
        items = [((i, j), u/r) for ((i, j), u) in a.items]
        return Map(items, a.hom)

    def transpose(a):
        items = [((j, i), v) for ((i, j), v) in a.items] # conjugate v?
        return Map(items, a.hom.transpose())

    def trace(a):
        assert a.hom.src == a.hom.tgt
        v = a.ring.zero
        for ((i, j), u) in a.items:
            if i==j:
                v += u
        return v

    def cokernel(a):
        A = a.to_array()
        B = elim.cokernel(a.ring, A)
        n = B.shape[0]
        X = Space(n, a.ring)
        hom = Hom(a.tgt, X)
        b = Map.from_array(B, hom)
        return b

    def kernel(a):
        A = a.to_array()
        B = elim.kernel(a.ring, A)
        n = B.shape[1] # src
        X = Space(n, a.ring)
        hom = Hom(X, a.src)
        b = Map.from_array(B, hom)
        return b

    def image(a):
        A = a.to_array()
        At = A.transpose()
        At = elim.row_reduce(a.ring, At, truncate=True)
        A = At.transpose()
        X = Space(A.shape[1], a.ring)
        hom = Hom(X, a.tgt)
        b = Map.from_array(A, hom)
        return b

    def rank(a):
        A = a.to_array()
        d = elim.rank(a.ring, A)
        return d


def dot(*maps):
    idx = 0
    A = maps[idx]
    while idx+1 < len(maps):
        B = maps[idx+1]
        A = A*B
        idx += 1 
    return A


def compose(*maps):
    maps = list(reversed(maps))
    A = dot(*maps)
    return A



def test_over_ring(ring):

    zero = Space.zero(ring)
    I = Space.unit(ring)

    A = Space("abcd", ring)
    B = Space("uv", ring)
    C = Space("1234", ring)
    D = Space("678", ring)

    assert str(A)
    assert (A@B)@C == A@(B@C)
    assert zero@A == A@zero == zero
    assert A@(B+C) == A@B + A@C

    a = A.get_basis(0)
    u = B.get_basis(0)
    v = B.get_basis(0)

    f = (a.transpose()@u) # kind of a mess...
    #print(f.hom)

    one = ring.one
    f = Map([(('u', 'a'), one), (('v', 'a'), one)], Hom(A, B)) # A--f-->B

    U = f.to_array()
    f1 = Map.from_array(U, f.hom)
    assert f==f1

    assert str(f)
    assert f-f == f.hom.zero_vector()
    assert f+f.hom.zero_vector() == f
    assert f*A.ident == f
    assert B.ident*f == f

    assert ((f @ A.ident) * A.cap).hom == Hom(I, B@A)
    assert ((A.ident @ f) * A.cap).hom == Hom(I, A@B)
    
    g = Map([(('6', '2'), one), (('8', '3'), one)], Hom(C, D)) # C--g-->D

    h = Map([(('d', 'a'), one), (('c', 'b'), one), (('c', 'c'), one)], Hom(A, A)) # A--g-->A

    assert f@(g@h) == (f@g)@h

    #print(h)

    # right zig-zag equation
    lhs = A.left_unitor * ( A.cup @ A.ident ) * ( A.ident @ A.cap )
    rhs = A.right_unitor
    assert lhs == rhs

    # left zig-zag equation
    lhs = A.right_unitor * ( A.ident @ A.cup ) * ( A.cap @ A.ident )
    rhs = A.left_unitor
    assert lhs == rhs

    # check dual is transpose
    for f in [h, g, f]:
        A, B = f.src, f.tgt
        lhs = A.left_unitor * ( B.cup @ A.ident ) * (B.ident @ f @ A.ident ) * ( B.ident @ A.cap )
        rhs = f.transpose() * B.right_unitor
        assert lhs == rhs

    #print(lhs)
    #print(rhs)

    assert (2*f) == f+f

    g = f.kernel()
    gf = dot(f, g)
    assert gf == gf.hom.zero_vector()

    g = f.cokernel()
    fg = dot(g, f)
    assert fg == fg.hom.zero_vector()

    # -----------------------------------------

    A = Space(2, ring)
    f = Map.from_array([[1, 1], [1, 1]], Hom(A, A))
    g = f.image()
    #print(g)

    assert f.trace() == 2


if __name__ == "__main__":


    test_over_ring(element.Z)
    test_over_ring(element.Q)
    test_over_ring(element.FiniteField(5))

    print("OK")



